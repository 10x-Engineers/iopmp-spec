[[Program_IOPMPs]]
:numbered:
== Programming IOPMPs
At times, it can be difficult or even impossible to configure all IOPMP settings when the system starts, especially before I/O agents are active or connected to the system. As a result, it is necessary to update IOPMP settings during runtime. This may occur when a device is enabled, disabled, added, removed, or when the accessible area of a device changes. When updating, it is important to avoid putting IOPMP in a transient metastable state due to incomplete settings. However, updating IOPMP settings often involves a series of control accesses, and if a transaction check occurs during the update, it can potentially create a vulnerability. 
It can be difficult for the security software to guarantee that no transactions are in progress from all related initiators. A false alarm could result in significant performance issues. This chapter describes an optional method for updating IOPMP's settings without intervening transaction initiators.

=== Atomicity Requirement
The term here "stable" refers to meeting the atomicity requirement. This implies that when updating an IOPMP, all transactions from input ports must be checked either before any changes or after completing all changes. Essentially, using partial settings in an IOPMP should be avoided. The succeeding sections will describe the mechanism to satisfy this requirement.

=== Programming Steps
The general approach to the atomicity requirement has three major steps, conceptually described as follows:

** Step 1: Stall related transactions. Before proceeding with any updates, delay checking the transactions that may be impacted. 
** Step 2: Update IOPMP's settings.
** Step 3: Resume stalled transactions. 

For step 1, it's important to verify if the necessary stalling transactions have taken place since they might not be instantaneous in certain implementations. Following this, execute the IOPMP update as step 2, and finally, resume all stalled transactions in step 3.

[NOTE]
====
In some cases, Step 1 and Step 3 may be skipped as long as no transaction check can interrupt Step 2. Updating MDs associated with a specific SID to other MDs is an example.
====

=== Stall Transactions
For Step 1, it's possible to postpone all transactions until all updates are finished. However, this could cause unrelated transactions to experience unnecessary delays. This might not be tolerable for devices that require low latency, like a display controller that periodically retrieves a frame from its video buffer. This section explains the mechanism that only stalls specific transactions to prevent the aforementioned scenario and ensure the atomicity requirement. All the features mentioned below are optional.

Since the stalls occur when updating is in progress, determining wheater a transaction's check should wait cannot be based on any IOPMP's configuration about to change. Therefore, the only information that can be relied upon for this decision is the SID carried by the transaction. To simplify the following description, we use a conceptual signal called sid_stall[__i__] to indicate whether the transaction with SID=__i__ must wait. Please note that it may not be an actual signal in practice and is not accessible directly for software.

A conceptual internal signal sid_stall has the same number of bits as the SIDs in the IOPMP. sid_stall is generated by the bit STALL_EXEMPT and the field STALL_BY_MD having the same number of bits as the memory domains in the IOPMP. When STALL_EXEMPT is zero, any non-zero value in STALL_BY_MD[__j__] will cause transactions with SID=__i__ to be stalled for all the SID __i__ associated with the MD __j__. On the contrary, on STALL_EXEMPT=1, checks of all transactions must wait except those with SID=__i__ associated with any MD __j__  and STALL_BY_MD[__j__] = 1. This relation can be more precisely described as follows:

[.text-center]
`sid_stall[__i__] <= STALL_EXEMPT ^ ( | (SRC__i__MD & STALL_BY_MD));`

There are two 32-bit registers, MD_STALL and MD_STALLH, to store STALL_EXEMPT and STALL_BY_MD. STALL_EXEMPT is in the LSB of MD_STALL, STALL_BY_MD[30:0] is in MD_STALL[31:1] and STALL_BY_MD[62:31] is in MD_STALLH. If any MD__j__ is not implemented, STALL_BY_MD[__j__] is wired to 0.

sid_stall should be captured only when STALL_EXEMPT is written, that is, MD_STALL is written. When MD_STALLH is written, the only action is to hold the value of STALL_BY_MD[62:31].

NOTE: Although sid_stall is related to the SRCMD table, but should be captured only when STALL_EXEMPT is written. The behavior of writing MD_STALL is used to capture a momentary snapshot of the table because the table may not be stable during the updating.

=== Cherry Pick
If MD_STALL doesn't stall all the desired transactions, there is an optional method to pick the transaction with specific SIDs. The SID_SCP register comprises two fields: a 2-bit SID_SCP.OP and a field for SID_SCP.SID. By setting SID_SCP.OP=1, the sid_stall[__i__] is activated for __i__=SID_SCP.SID. Conversely, by setting SID_SCP.OP=2, the sid_stall[__i__] is deactivated for __i__=SID_SCP.SID. This register can be considered as the fine-tuning sid_stall after MD_STALL. The value of SID_SCP.OP=0 is to query the sid_stall indirectly, and the value of 3 is reserved.

=== Resume Stall
In order to resume all stalled transactions, the IOPMP can be prompted by writing 0 to MD_STALL. This corresponds to Step 3 of the "Programming Steps" section.

=== The Order to Stall
In Step 1 of programming IOPMP, MD_STALL can be written at most once and before any SID_SCP is written. After a resume, writing a non-zero value to MD_STALL multiple times leads to an undefined situation.

SID_SCP can be written multiple times or not at all. To determine whether all requested stalls take effect, one can read back the bit MD_STALL.IS_STALLED, which is in the same location as MD_STALL.EXEMPT on a write. MD_STALL.IS_STALLED=1 indicates all requested stalls taking effect.

To query if all transactions associated with a specific SID are stalled, do the following. First, write 0 to SID_SCP.OP and the SID you want to query to SIC_SCP.SID. Then, read back SID_SCP. The readback of SID_SCP.STAT = 1 means that transactions with the queried SID have stalled, that is, the corresponding bit in sid_stall is 1. If the value is 2, it means they are not stalled. A value of 3 indicates an unimplemented or unselectable SID in SID_SCP.SID. SID_SCP.STAT is in the same location as SID_SCP.OP on a write. SID_SCP.SID should keep the last written legal SID and SID_SCP.STAT reflects the current state of this SID. This method is considered an indirect way to read sid_stall.

=== Implementation-Dependecy
All registers described in this chapter are optional. Moreover, these features could be partially implemented. In STALL_BY_MD, not every bit should be implemented even though the corresponding MD is implemented. An unimplemented bit means unselectable and should be wired to zero. To test which bits are implemented, one can write all 1's to MD_STALL and MD_STALLH and then read them back. An implemented bit returns 1.

If an IOPMP implementation has fewer than 32 memory domains, MD_STALLH should be wired to zero.

NOTE: An example of partial implementation of STALL_BY_MD is a system with a display controller, which is a latency-sensitive device. On updating the IOPMP, the transactions initiated from the display controller should not be stalled. Thus, one can always use STALL_EXEMPT=1 and STALL_BY_MD[__j__]=1, where MD__j__ is the memory domain for the frame buffer of the display controller. Thus, the system only needs to implement STALL_BY_MD[__j__].

If the whole MD_STALL is not implemented, MD_STALL and MD_STALLH should always return zero, which means no bit implemented in STALL_BY_MD.

If SID_SCP is not implemented, it always returns zero. One can test if it is implemented by writing a zero and then reading it back. Any IOPMP implementing SID_SCP should not return a zero in SID_SCP.STAT in this case.

It is unnecessary to allow every implemented SID to be selectable by SID_SCP.SID. If an unimplemented or unselectable SID is written into SID_SCP.SID, it will return SID_SCP.STAT = 3 to respond to any defined SID_SCP.OP.
