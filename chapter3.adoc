[[IOPMP_Models]]
== IOPMP Models

The spec offers several IOPMP configuration models to accommodate varied platforms. Users can choose one of the models that best fits the use cases, including those for low area, low power, low latency, high throughput, high portability, and other criteria.

=== The Full Model

When a full model IOPMP receives a transaction with SID _s_, IOPMP first lookups the SRCMD table to find out all the memory domains associated to source _s_. An IOPMP instance can support up to 256 sources, the actual number of sources can be implementation-defined and is indicated in the HWCFG0 register. Each entry in the SRCMD table defines the mapping of MDs to a specific source with SID _s_. An SRCMD entry must impelment an SRCMD_EN(_s_) register, and is optionally to implement SRCMD_R(_s_) and SRCMD_W(_s_) if SPS extension is supported, see details in Appendix A3. 
Register SRCMD_EN(_s_) is occupies a 64-bit space, and has two fields, SRCMD_EN(_s_).l and SRCMD_EN(_s_).md. SRCMD_EN(_s_).l is the sticky lock to register SRCMD_EN(_s_). In the full model, SRCMD_EN(_s_).md is a bitmapped field and has up to 63 bits. Each bit in SRCMD_EN(_s_).md indicates if the corresponding MD is associated with the SID _s_. For unimplemented memory domains, the corresponding bits in SRCMD(_s_).md should be WARZ. A full model IOPMP supports up to 63 memory domains. For a system requiring more memory domains than 63, please refer to Appendix A2.

Once IOPMP retrieves all associated MDs for a transaction with SID _s_ from the SRCMD table, it looks up the corresponding IOPMP entries belonging to these MDs. The MDCFG table has an array of registers where the register MDCFG(_m_) is for the memory domain _m_. One field, MDCFG(_m_).t, indicates the top index of the IOPMP entry belonging to the memory domain _m_. An IOPMP entry with index _j_ belongs to MD _m_ if MDCFG(_m-1_).t &#8804; _j_ < MDCFG(_m_).t, where _m_ > 0. The MD 0 owns the IOPMP entries with index j < MDCFG(0).t. Each MDCFG register occupies a 32-bit space and the field MDCFG(_m_).t occupies the lowest 16 bits. The number of implemented bits is implement-dependent.

After retrieving all associated IOPMP entries, a full model IOPMP checks the transaction according to these entries.

=== Configuration Protection

A hardwire behavior that makes an IOPMP fully or partially nonprogrammable unless resetting the IOPMP is the so-called “lock.” A lock in an IOPMP is similar to that in a PMP. It can ensure critical settings are unchanged even though the security monitor is compromised. 

==== Protect the SRCMD Table 
In certain use cases, the user may want to ensure a specific MD is enabled with (associated to) all sources. For example, one may want to set MD 0 as a denylist region where all sources has no access to memories in this region. A register MDLCK is defined to set lock on specific MDs for all sources. MDLCK has two fields: a 63-bit MDLCK.md and a 1-bit MDLCK.l. If MDLCK.md[_m_] == 0x1, for all SIDs, SRCMD.md[_m_] is not programmable. MDLCK.l is the lock bit for the MDLCK. In the above example, when you want to enforce every SID to associate MD 0, you can first set all SRCMD(_s_).md[0]=1, and then let MDLCK.md[0]=1. The rest mappings are still programmable. If MDLCK is not implemented, it should be WARZ.

For unimplemented memory domains, the corresponding bits of MDLCK.md should be WARZ. The bits for implemented memory domains in MDLCK.md can be also hardwired. However, in this case, the corresponding bits in SRCMD(_s_).md should be well initialized during reset process. If whole MDLCK.md is hardwired, MDLCK.l should be wired to 1. The user can detect the number of implemented memory domain through HWCFG0 register.

Besides, every SRCMD register has an optional bit, L, which is used to lock this register. It is a convenient way to lock the MD mapping of an SID without consuming any IOPMP entry. If a programmable SRCMD(_s_).l is implemented, SRCMD(_s_).l should be initialized to zero after reset. If SRCMD(_s_).l is not implemented, it can be hardwired to 0 or 1. If it is wired to 1, SRCMD(_s_).md should be hardwired properly.

==== Protect the MDCFG Table
Subsequently, the MDCFG table can also be locked. The register MDCFGLCK is designed for the purpose, which has two fields: MDCFGLCK.l and MDCFGLCK.f. Please note that if the top index of MD _m_ is locked, that of DM _m-1_ should be locked, too. Otherwise, the IOPMP entries of MD m can be added or removed by modifying MDCFG(_m-1_).t. By introduction, if MD m is locked, MD n should also be locked, where _n_ < _m_. MDCFG(_m_) are nonprogrammable if _m_ < MDCFGLCK.f. MDCFGLCK.f is initialized to 0 after reset, and can be increased only when written. MDCFGLCK.l is the lock of MDCFGLCK. If MDCFGLCK is hardwired, MDCFGLCK.l should be wired to 1.

IOPMP entry protection is also related to the other IOPMP entries belonging to the same memory domain. For a MD, locked entries should be placed in the higher priority. Otherwise, when the security monitor is compromised, one unlocked entry in higher priority can overwrite all the other locked entries in lower priority.  A register ENTRYLCK is define to indicate the number of nonprogrammable entries. The ENTRYLCK register has two fields: ENTRYLCK.l and ENTRYLCK.f. Any IOPMP entry with index _i_ &#8804; ENTRYLCK.f is not programmable. ENTRYLCK.f is initialized to 0 and can be increased only when written. Besides, ENTRYLCK.l is the lock to ENTRYLCK.f and itself. If ENTRYLCK is hardwired, ENTRYLCK.l should be wired to 1.

=== The Rapid-_k_ Model

To shorten the latency, the rapid-_k_ model replaces the lookup of the MDCFG table by simple logics. Every memory domain has exactly _k_ IOPMP entries where _k_ is implementation-dependent and hardwired. Since _k_ is a fixed number, once MDs are retrieved for a transaction, these indexes of selected MDs can quickly transform into the signals to pick up the IOPMP entries. An extreme case is _k_=1 in which every non-zero bit in SRCMD(_s_).md directly maps to a selected IOPMP entry for SID=_s_.

To make it semantically compatible with the full model, the realated fields should be read with their original meanings. MDCFGLCK.f should be the same as the number of implemented MDs and MDCFGLCK.l should be 1. MDCFG(_m_).t should be (_m_)+1)*_k_. That is, one can read MDCFG(0).t to retrieve the value _k_.

MDCFG(_m_).f and MDCFG(_m_).l can still be programmable or hardwired. The two fields typically do not affect the latency of checking a transaction. They are usually related to writing to IOPMP registers, and writing latency is not a concern in this model.

=== The Dynamic-_k_ Model

The dynamic-_k_ model is similar to the rapid-_k_ model, except the _k_ value is programmable. If you have a fixed number of IOPMP entries, you probably don’t need this model. You can simply divide all IOPMP entries evenly to every memory domain and obtain a fixed k. However, if the IOPMP array is not in dedicated storage and could be shared for other purposes, the dynamic-_k_ model helps partition these IOPMP entries. 

The IOPMP entry reassignment is not suggested during the run time. The boot time is a better choice.

MDCFG(0).t stores the value _k_ and is WARL. That is, an implementation may accept limited _k_. However, zero should not be a legal value. One should make sure if a written value is legal by reading it back. The _k_ is usually considered as a power of 2 for easier hardware implementation. MDCFG(_m_).t is read-only and equals to (_m_+1)*_k_ when it is read. By updating MDCFG(0).t and then examining MDCFG(1).t’s change, one can know the IOPMP is the dynamic-_k_ model.

MDCFGLCK.f should be zero right after the IOPMP resets. MDCFGLCK.f and MDCFGLCK.l can be programmable or hardwired. If MDCFGLCK.f is programmable, it can only accept two values: 0 and the number of MDs.

=== The Isolation Model

One of the benefits of the full model is to share common memory regions (by memory domains) among different SIDs. The isolation model can be implemented for the case of no or a few shared regions. In this model, each SID is exactly associated with one MD. Thus, no table-lookup is needed to retrieve the associated MD. It benefits the area as well as the latency. The penalty is to duplicate IOPMP entries when two SIDs do share regions. Besides, even though MDLCK and all SRCMD(_s_) should be read-only, to ensure the semantic compatibility to the full model, following rules are defined: for reading SRCMD(_s_), SRCMD(_s_).md should be 1<<s, and SRCMD(_s_).l should be 1. As to MDLCK.md, all implemented MDs should be hardwired to 1. MDLCK.l should also be wired to 1.
There is no constrain on the MDCFG table and the MDCFGLCK register.

=== The Compact-_k_ Model

The compact-_k_ model can achieve even lower latency and smaller area than the isolation model. Besides having each SID exactly associated with one MD, every MD should have exactly k IOPMP entries. Once SID is known, the IOPMP entries can be selected efficiently. In the model, MDLCK, all SRCMD, MDCLK, and all MDCFG.t are read-only. When read, MDLCK and all SRCMD should be the same as the isolation model. MDCFGLCK and all MDCFG.t should be the same as the rapid-k model.
MDCFG.l and MDCFG.f can still be programable or hardwired.


=== Model Detections

To distinguish the above models, the user can read register HWCFG1.model to determine the current implemented IOPMP model.
